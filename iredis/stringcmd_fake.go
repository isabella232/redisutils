// This file was generated by counterfeiter
// counterfeiter -o iredis/stringcmd_fake.go --fake-name StringCmdFake iredis/stringcmd.go StringCmd

package iredis

import "sync"

//StringCmdFake ...
type StringCmdFake struct {
	ResultStub        func() (string, error)
	resultMutex       sync.RWMutex
	resultArgsForCall []struct{}
	resultReturns     struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

//NewStringCmdFake is the preferred way to initialise a StringCmdFake
func NewStringCmdFake() *StringCmdFake {
	return new(StringCmdFake)
}

//Result ...
func (fake *StringCmdFake) Result() (string, error) {
	fake.resultMutex.Lock()
	fake.resultArgsForCall = append(fake.resultArgsForCall, struct{}{})
	fake.recordInvocation("Result", []interface{}{})
	fake.resultMutex.Unlock()
	if fake.ResultStub != nil {
		return fake.ResultStub()
	}
	return fake.resultReturns.result1, fake.resultReturns.result2
}

//ResultCallCount ...
func (fake *StringCmdFake) ResultCallCount() int {
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	return len(fake.resultArgsForCall)
}

//ResultReturns ...
func (fake *StringCmdFake) ResultReturns(result1 string, result2 error) {
	fake.ResultStub = nil
	fake.resultReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

//Invocations ...
func (fake *StringCmdFake) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	return fake.invocations
}

func (fake *StringCmdFake) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ StringCmd = new(StringCmdFake)
