// This file was generated by counterfeiter
// counterfeiter -o iredis/boolslicecmd_fake.go --fake-name BoolSliceCmdFake iredis/boolslicecmd.go BoolSliceCmd

package iredis

import "sync"

// BoolSliceCmdFake ...
type BoolSliceCmdFake struct {
	ResultStub        func() ([]bool, error)
	resultMutex       sync.RWMutex
	resultArgsForCall []struct{}
	resultReturns     struct {
		result1 []bool
		result2 error
	}
	ErrStub        func() error
	errMutex       sync.RWMutex
	errArgsForCall []struct{}
	errReturns     struct {
		result1 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct{}
	stringReturns     struct {
		result1 string
	}
	ValStub        func() []bool
	valMutex       sync.RWMutex
	valArgsForCall []struct{}
	valReturns     struct {
		result1 []bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

//NewBoolSliceCmdFake is the preferred way to initialise a BoolSliceCmdFake
func NewBoolSliceCmdFake() *BoolSliceCmdFake {
	return new(BoolSliceCmdFake)
}

//Result ...
func (fake *BoolSliceCmdFake) Result() ([]bool, error) {
	fake.resultMutex.Lock()
	fake.resultArgsForCall = append(fake.resultArgsForCall, struct{}{})
	fake.recordInvocation("Result", []interface{}{})
	fake.resultMutex.Unlock()
	if fake.ResultStub != nil {
		return fake.ResultStub()
	}
	return fake.resultReturns.result1, fake.resultReturns.result2
}

//ResultCallCount ...
func (fake *BoolSliceCmdFake) ResultCallCount() int {
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	return len(fake.resultArgsForCall)
}

//ResultReturns ...
func (fake *BoolSliceCmdFake) ResultReturns(result1 []bool, result2 error) {
	fake.ResultStub = nil
	fake.resultReturns = struct {
		result1 []bool
		result2 error
	}{result1, result2}
}

//Err ...
func (fake *BoolSliceCmdFake) Err() error {
	fake.errMutex.Lock()
	fake.errArgsForCall = append(fake.errArgsForCall, struct{}{})
	fake.recordInvocation("Err", []interface{}{})
	fake.errMutex.Unlock()
	if fake.ErrStub != nil {
		return fake.ErrStub()
	}
	return fake.errReturns.result1
}

//ErrCallCount ...
func (fake *BoolSliceCmdFake) ErrCallCount() int {
	fake.errMutex.RLock()
	defer fake.errMutex.RUnlock()
	return len(fake.errArgsForCall)
}

//ErrReturns ...
func (fake *BoolSliceCmdFake) ErrReturns(result1 error) {
	fake.ErrStub = nil
	fake.errReturns = struct {
		result1 error
	}{result1}
}

func (fake *BoolSliceCmdFake) String() string {
	fake.stringMutex.Lock()
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct{}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	return fake.stringReturns.result1
}

//StringCallCount ...
func (fake *BoolSliceCmdFake) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

//StringReturns ...
func (fake *BoolSliceCmdFake) StringReturns(result1 string) {
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

//Val ...
func (fake *BoolSliceCmdFake) Val() []bool {
	fake.valMutex.Lock()
	fake.valArgsForCall = append(fake.valArgsForCall, struct{}{})
	fake.recordInvocation("Val", []interface{}{})
	fake.valMutex.Unlock()
	if fake.ValStub != nil {
		return fake.ValStub()
	}
	return fake.valReturns.result1
}

//ValCallCount ...
func (fake *BoolSliceCmdFake) ValCallCount() int {
	fake.valMutex.RLock()
	defer fake.valMutex.RUnlock()
	return len(fake.valArgsForCall)
}

//ValReturns ...
func (fake *BoolSliceCmdFake) ValReturns(result1 []bool) {
	fake.ValStub = nil
	fake.valReturns = struct {
		result1 []bool
	}{result1}
}

//Invocations ...
func (fake *BoolSliceCmdFake) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	fake.errMutex.RLock()
	defer fake.errMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.valMutex.RLock()
	defer fake.valMutex.RUnlock()
	return fake.invocations
}

func (fake *BoolSliceCmdFake) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ BoolSliceCmd = new(BoolSliceCmdFake)
